#!/usr/bin/env ruby

public

require 'optparse'
require 'open3'

begin
  require 'highline'
  require 'colored'
  require 'terminfo'
rescue LoadError => x
  puts <<-XXX
To run this utility:
  gem install 'highline'
  gem install 'colored'
  gem install 'ruby-terminfo'
XXX
  exit(1)
end

class KRubocop
  attr_accessor :app, :rack, :command, :service_filter, :op, :any, :instance_id

  CONVOX_BIN = `which convox`.strip

  def initialize
    @rack = `convox switch`.strip
    @app = nil
    @command = 'bash'
    @service_filter = /.*/
    @any = false
  end

  def konnect_error(message)
    puts("#{op.banner}.\n\nError: #{message}")
    exit 1
  end

  def go
    self.parse_opts

    self.check_for_convox

    ids_to_names = self.filtered_id_to_name_map

    all_names_the_same = ids_to_names.values.uniq.size.eql?(1)

    if all_names_the_same && self.any
      self.instance_id = ids_to_names.keys.sample
    else
      self.instance_id = choose_service(ids_to_names)
    end

    temp_file = 'temp-rubocop-output.txt'
    # Fire it up
    cmd = build_convox_command('bundle exec rubocop -a') + " > #{temp_file}"
    info "Running: #{cmd}"
    exec_command(cmd)

    info "Reading file #{temp_file}"
    pattern = /([\w^ ]+(\/[\w^ ]+)+\.rb)\:[\d]+\:[\d]+/
    all_matches = []
    File.foreach(temp_file) do
      |line|
      if matches = line.match(pattern)
        all_matches.push(matches[1])
      end
    end
    all_matches = all_matches.uniq
    File.delete(temp_file)

    zip_config_path = "files_to_zip.txt"
    zip_config_file = File.open(zip_config_path, "w")
    all_matches.each do
      |file|
      # TODO: why the hell is convox using winwows newlines?
      # convert newlines using "tr -d '\r'"
      cmd = build_convox_command("cat '#{file}'") + " | tr -d '\r' > '#{file}'"
      info "Copying #{file} from convox machine to local path"
      if exec_command(cmd)
        zip_config_file.puts(file)
      end
    end
    zip_config_file.close

    cmd = 'zip rubocop_chaged_files.zip -@ < files_to_zip.txt'
    info "Creating a zip with all modified files"
    if exec_command(cmd)
      File.delete(zip_config_path)
      info "Success. "
    end
  end

  def exec_command(cmd)
    %x[ #{cmd} ]
  end

  def build_convox_command(command)
    # Fire it up
    cmd = "#{CONVOX_BIN} exec --rack #{self.rack} --app #{self.app} #{self.instance_id} '#{command}'"
  end

  def parse_opts
    self.op = OptionParser.new do |opts|

      opts.banner = <<-BAN

A wrapper around convox exec that runs rubocop with autofix option inside the container and downlaods the modified files.

If you provide no command to run, it runs 'bash'.

Ex:
      krubocop -r local/convox -a falkor-game-service
        # run the command on any instance that matches the filter

BAN

      opts.separator ""
      opts.separator "Specific options:"

      opts.on("-z", "--debug", "Optional: load pry") do |x|
        require 'pry'
      end

      opts.on("-c", "--rack=R", "Optional, the command, default: 'bash'") do |x|
          self.command = x
      end

      opts.on("-r", "--rack=R", "Optional, the convox rack") do |x|
          self.rack = x
      end

      opts.on("-a", "--app=A", "Optional, the convox app.") do |x|
        self.app = x
      end

      opts.on("-s", "--service=S", "Required: which service (a regex)") do |x|
        regexes = x.split(',').map(&:strip)
        self.service_filter = /#{x}/
      end

      opts.on("-n", "--any", "Optional, connect to any matching instance.") do |x|
        self.any = x
      end

    end

    op.parse!(ARGV)

    if self.app.nil?
      info "--app not provided, using 'kraken'"
      self.app = 'kraken'
    end

  end

  def check_for_convox
    if CONVOX_BIN.to_s.empty?
      konnect_error "Command 'convox' was not found in your PATH"
    end
  end

  def id_name_map
    cmd = "#{CONVOX_BIN} ps --rack #{self.rack} --app #{self.app}"
    info cmd
    stdout, stderr, status = Open3.capture3(cmd)
    if status.exitstatus.eql?(1)
      konnect_error(stderr)
    end

    lines = stdout.lines[1..-1]

    # Create a map of instance id to instance name
    id_to_name_map = Hash[lines.map do |line|
      line.split(/\s{2,}/).first(2)
    end]
    id_to_name_map
  end

  def filtered_id_to_name_map
    services_map = self.id_name_map
    services_map.delete_if{|k,v| "#{k}-#{v}" !~ self.service_filter}
    if services_map.empty?
      konnect_error "No services matched #{self.service_filter}"
    end
    services_map
  end

  def choose_service(service_map)
    return service_map.keys.first if service_map.size.eql?(1)

    puts "\n"
    choice = nil
    cli.choose do |menu|
      menu.prompt = "\nWhich service?".yellow
      service_map.each do |id, name|
        menu.choice("#{name} #{id}") { choice = id }
      end
      menu.choice('quit') { exit 0 }
    end
    choice
  end

  def info msg
    $stderr.puts msg.blue
  end

  def screen_rows
    TermInfo.screen_size.first
  end

  def screen_columns
    TermInfo.screen_size.last
  end

  def cli
    @_cli = HighLine.new
  end
end

KRubocop.new.go
