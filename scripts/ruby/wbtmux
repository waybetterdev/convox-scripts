#!/usr/bin/env ruby

public

require 'optparse'
require 'open3'

begin
  require 'highline'
  require 'colored'
  require 'terminfo'
rescue LoadError => x
  puts <<-XXX
To run this utility:
  gem install 'highline'
  gem install 'colored'
  gem install 'ruby-terminfo'
XXX
  exit(1)
end

require File.expand_path('../', __FILE__) + "/includes/op-base.rb"

# CLI script which will start tmux
class Wbtmux < OpBase
  attr_accessor :option_parser, :apps_to_run, :apps_to_open, :opt_exit_tmux, :opts_fix_dns, :opts_wait_convox

  DEFAULT_SERVICES = ['mysql', 'user']
  SERVICE_MAP = {
    "mysql"       => 'kraken/superlocal',
    "user"        => 'wb-user-service',
    "auth"        => 'wb-auth-service',
    "bill"        => 'wb-billing-service',
    "graphql"     => 'wb-graphql-service',
    "dietbet"     => 'dietbet-game-service',
    "hub"         => 'wb-hub',
    "admin-auth"  => 'wb-admin-auth-service',
    "admin-web"   => 'wb-admin-web',
    "metric"      => 'wb-metric-service',
    "notify"      => 'wb-notify-service',
    "member"      => 'wb-membership-service',
    "falkor"      => 'falkor-game-service',
    "runbet"      => 'runbet-game-service',
    "quitbet"     => 'quitbet-game-service',
    "social"      => 'wb-social-service',
  }
  ALL_SERVICES = SERVICE_MAP.keys
  def initialize()
    @path = "#{Dir.home}/Work/wb-services"
    @bin_path = "#{Dir.home}/Work/docs/scripts/ruby"
    @apps_to_open = []
    @apps_to_run = [] 
  end

  def go

    parse_opts

    run_tmux_session()
  end

  def app_full_name(name)
    SERVICE_MAP[name]
  end

  def run_tmux_session()

    fix_dns_and_aws if self.opts_fix_dns

    if convox_required? && !kubernetes_ready?
      puts "Kubernetes (microk8s) not running. Starting it"
      start_kubernetes 
    end

    wait_for_convox if self.opts_wait_convox 
    if convox_required?
      exit_with_error("Convox not ready. Aborting.") unless convox_ready?
    end

    session_name = 'lconvox'

    all_apps = self.apps_to_run + self.apps_to_open.uniq

    if all_apps.count > 0 
      prepare_session(session_name)

      open_apps(session_name, all_apps)
      run_apps(session_name, self.apps_to_run)

      unless self.opt_exit_tmux
        enter_tmux_session(session_name)
      end
    end

    if self.opt_exit_tmux
      exit_tmux_session(session_name)
    end
  end

  def prepare_session(session_name)

    if session_exists?(session_name)
      exit_tmux_session(session_name)
    else
      queue = CommandQueue.new(session_name)
      queue.create_session("info", @path)
      queue.run
    end
  end

  def open_apps(session_name, apps)

    return if apps.nil?

    active_windows = list_windows(session_name)

    queue = CommandQueue.new(session_name)
    queue.attach_session()

    apps.each do |app|
      next if active_windows.include?(app)
      convox_app = app_full_name(app)
      path = convox_app_path(convox_app)
      queue.new_window(app, path)
    end

    queue.run
  end

  def run_apps(session_name, apps)
    return if apps.nil?

    # reload window list
    active_windows = list_windows(session_name)

    apps.each do |app|
      next unless active_windows.include?(app)

      convox_app = app_full_name(app)
      app_command = ''
      if app == 'mysql'
        app_command = 'docker-compose up'
      elsif np_service_is_on_local_convox(convox_app)
        # create the app if it does not exist
        if convox_app_path_exists?(convox_app) && self.opts_wait_convox && !convox_app_exists?(convox_app, use_cache: true)
          create_convox_app(convox_app)
        end 

        app_command = "env-builder -w -a #{app} && kk refresh-yml -- local #{app} && kk refresh-env -- local #{app} no-confirm && startconvoxapp"
      elsif np_service_is_on_local_kraken(convox_app)

        app_path = np_service_path(convox_app)

        if np_service_is_node(convox_app)
          exec_command "install-node-app -a #{app}" unless convox_app_path_exists?(convox_app)
          app_command = "npmstartservice"
        elsif np_service_is_ruby(convox_app)
          exec_command "install-node-app -a #{app}" unless convox_app_path_exists?(convox_app)
          app_command = "cd #{app_path} && lrun bin/start_web_server.sh"
        else
          throw "Could not detect whether '#{convox_app}' is a ruby or node app." 
        end
      end

      queue = CommandQueue.new(session_name)
      queue.attach_session
      queue.exec_command_inside_screen(app, 1, app_command)
      
      queue.swap_panes(0, 1)
      queue.run
    end
  end

  def exit_tmux_session(session_name)
    exec_command("tmux send-keys -t \"0\" C-z 'tmux detach-client -s #{session_name}' Enter")
  end

  def enter_tmux_session(session_name)
    exec_command("tmux attach-session -t #{session_name}")
  end

  def parse_opts
    self.option_parser = OptionParser.new do |opts|

      opts.banner = HELP

      opts.separator ""
      opts.separator "Specific options:"

      opts.on("-z", "--debug", "Optional: load pry") do |x|
        require 'pry'
      end

      opts.on("-r", "--run=S", "Optional, the apps to run") do |x|
        self.apps_to_run = x.split(",").collect(&:strip)
      end

      opts.on("-o", "--open=O", "Optional, the apps to open") do |x|
        self.apps_to_open = x.split(",").collect(&:strip)
      end

      opts.on("-x", "--exit", "Optional, exit current tmux session without killing it") do |x|
        self.opt_exit_tmux = true
      end

      opts.on("-f", "--fixdns", "Optional, Fix convox dns") do |x|
        self.opts_fix_dns = true
      end

      opts.on("-w", "--wait", "Optional, wait for convox") do |x|
        self.opts_wait_convox = true
      end

      opts.on("-h", "--help", "Prints this help") do
        puts opts
        exit
      end

    end
    self.option_parser.parse!(ARGV)

    validate_service_names(self.apps_to_run)
    validate_service_names(self.apps_to_open)
  end

  def validate_service_names(services)
    return if services.nil?

    services.each do |s|
      exit_with_error "Service '#{s} 'not found" unless ALL_SERVICES.include?(s)
    end
  end


  def exit_with_error(msg)
    puts msg
    puts "See help:"
    show_help
    exit(1)
  end

  def list_windows(session_name)
    res = exec_command("tmux list-windows -t '#{session_name}' " + '-F \'#{window_name}\'')
    res.split("\n")
  end

  def session_exists?(name)
    system("tmux has-session -t #{name} 2>/dev/null") == true
  end

  def exec_command(cmd)
    puts "Running Command:"
    puts cmd.blue
    cmd.gsub("'", "\\\\'")
    %x[ #{cmd} ]
  end

  def convox_required?
    @__convox_required ||= begin
      res = self.apps_to_run.find do |s| 
        next if s == 'mysql'
        name = app_full_name(s)
        next unless name
        np_service_is_on_local_convox(name)
      end
      !res.nil?
    end
  end

  def wait_for_convox
    12.times do 
      break if convox_ready?

      puts "Convox not ready. Waiting 10 seconds"
      exec_command("sleep 10")
    end
  end

  def fix_dns_and_aws
    puts 'Fixing iptables'
    exec_command("sudo iptables -P FORWARD ACCEPT")

    puts 'Fixing aws'
    pass = exec_command("aws ecr get-login-password --region us-west-2 --profile prod")
    exec_command("convox registries add 247028141071.dkr.ecr.us-west-2.amazonaws.com AWS #{pass}")
  end
  
  HELP = <<-END
wbtmux
  Wrapper script for tmux. Can run any of the following services #{SERVICE_MAP.keys.join(",")}
  Ex:
    
    or 
    wbtmux -r mysql,user -o auth,falkor
  
  END

  def show_help
    puts HELP
  end

  class CommandQueue
    attr_accessor :commands, :session_name
    def initialize(session_name)
      @commands = []
      @session_name = session_name
    end

    def create_session(screen_name, path)
      _add "new-session -c '#{path}' -n \"#{screen_name}\" -s '#{session_name}'"
    end

    def attach_session
      _add "attach-session -t #{session_name}"
    end

    def new_window(name, path)
      _add "new-window -c #{path} -n \"#{name}\" /bin/bash -i"
      _add "split-window -v -c #{path} /bin/bash -i"
    end

    def exec_command_inside_screen(screen, pane, command)
      _add "select-window -t #{screen}"
      _add "send-keys -t #{pane} C-z '#{command}' Enter"
    end

    def swap_panes(src, dst)
      _add "swap-pane -s #{src} -t #{dst}"
    end

    def exit_session
      _add "select-window -t 'info'"
      _add "send-keys -t \"0\" C-z 'tmux detach-client -s #{session_name}' Enter"
    end

    def run
      exit_session
      exec_command("tmux " + commands.join(" \\; \\\n    ") + "\\;")
    end

    def exec_command(cmd)
      puts "Running Command:"
      puts cmd.blue
      cmd.gsub("'", "\\\\'")
      %x[ #{cmd} ]
    end

    private
    def _add(cmd)
      commands.push(cmd)
    end

    # Time.now.strftime('%Y-%m-%d %H:%M:%S')
  end

end

Wbtmux.new.go


